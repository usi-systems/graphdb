
1. Cost model:

- Need to model on a per-block basis:
  - assume that for a block, we already have some partitioning
  - We get some query workload

  - The I/O for queries should capture not only the attribute cost, 
    but also the neighbor list.
  Problem (1):
  - The current formulation doesn't capture the neighbor list.

  Problem (2):
  - The current formulation doesn't include the time stamp.
  - Need to look at the frequency of queries that cover the block time span.

  Problem (3):
  - Question: which subblock to read
  - Heuristic: pick the sub-block with the highest "value". Size of ab/ sizeof (abc)... 
  - Can't pre-compute, but we need to have some knowledge of "what attributes are in the block". We need some index structure...
  - Will this have an impact on the storage cost?

Question:

- Given a partitioning and query, we need a function that returns the set of
  sub-blocks that satisfy the query...
- For each sub-block:
  - Some attributes that you use, some you don't.
  - Pick the sub-block that has the highest "value"
  - Repeat until we've accessed all necessary sub-blocks...

  - This computation should be fast:
  - This is an algorithm.


Overlapping vs. Non-overlapping.
  - Non-overlapping: then you can just pick the sub-block
  - If overlapping: then you need a heuristic to pick which sub-block.
  - When we implement, we should implement both and compare the performance
  - Overlapping: advantage is if the benefit of less I/O outweighs the cost
    of doing the computation to determine which block...

TODOs:
  - rjs to make another pass at the query I/O

 




