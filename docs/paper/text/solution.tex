\clearpage
\newpage
\section{Partitioning}
This section is still a work-in-progress. We are trying to find the algorithms.

\subsection{Non-Overlapping Attributes}

\paragraph*{Problem.$\,$} \emph{Find a true partitioning of attributes that
minimizes the query I/O and bounds the storage cost by some upper limit.}

\subsubsection{Integer Linear Program Formulation}
We present an ILP formuation of the problem. For this purpose, we define a 
number of binary ($0$ or $1$) variables: 
\begin{itemize}
\item $x_{a,p}$: $1$ if attribute $a$ is in partition $p$, $0$ otherwise.
\item $y_{p,q}$: $1$ if partition $p$ is used by query $q$, $0$ otherwise.
\item $z_{a,p,q}$: $1$ if partition $p$ is used by query $q$ and attribute $a$
is in partition $p$, $0$ otherwise.
\item $u_{p}$: $1$ if partition $p$ is assigned at least $1$ attribute, $0$ otherwise.
\end{itemize}

Each of these variables serve a purpose:
\begin{itemize}
\item $x$s define the attribute-to-partition assignment.
\item $y$s help formulate the query I/O contribution
of partitions, excluding their assigned attributes.
\item $z$s help formulate the query I/O contribution
of partitions, only considering their assigned attributes.
\item $u$s help formulate the storage overhead requirement.
\end{itemize}

We also define a helper notation for representing whether a variable is
accessed by a query or not: $q(a)\equiv \mathbf{1}(a \in q.A)$, where
$\mathbf{1}$ is the indicator function. We assume that there are a maximum of
$k$ partitions. $k$ can be taken as $|A|$, as there cannot be more partitions
than there are attributes.

We are now ready to state the ILP formulation. We start with the objective
function, that is the total query I/O:
\begin{eqnarray}
\sum_{q\in Q} \sum_{p=1}^{k} && (16\cdot c_e(B) + 12\cdot c_n(B))\cdot
y_{p,q}\nonumber\\ 
&+& \sum_{a\in A} s(a)\cdot c_e(B)\cdot z_{a,p,q}\label{eq:no-obj}
\end{eqnarray}

In Eq.~\ref{eq:no-obj}, we simply sum for each query and each partition, and
add the I/O cost of reading in the structural information found in a
sub-block, if the partition is used by the query. We then sum over each
attribute as well, and add the I/O cost of reading in the attributes. Note
that $z_{a,p,q}$ could have been  replaced with $x_{a,p}\cdot y_{p,q}$, but
that would make the objective function non-linear. 

We are now ready to state our constraints. Our first constraint is that, each
attribute must be assigned to a single partition. Formally:
\begin{eqnarray}
\forall_{a\in A}, \sum_{p=1}^{k} x_{a,p} = 1
\end{eqnarray}

Our second constraint is that, if a query $q$ contains an attribute $a$
assigned to a partition $p$, then partition $p$ is used by the query, i.e.,
$y_{p,q}=1$. In essence, we want to state: $\forall_{\{p,q\}\in [1..k]\times
Q}, y_{p,q} = \mathbf{1}(\sum_{a\in A} q(a)\cdot x_{a,p}>0)$. 

In order to formulate this constraint, we use the following ILP  construction:
Assume we have two variables, $\beta_1$ and $\beta_2$, where $\beta_2\in[0,1]$
and $\beta_1\geq 0$. We want to implement the following constraint: $\beta_2 =
\mathbf{1}(\beta_1 > 0)$. This could be expressed as a linear constraint as
follows, where $K$ is a large constant guaranteed to be larger than $\beta_1$
for practical purposes:
\begin{eqnarray}
&& \beta_1 - \beta_2 \geq 0\nonumber\\
&& K\cdot\beta_2 - \beta_1 \geq 0\nonumber
\end{eqnarray}

We now apply this construction to our second constraint, where
$\beta_1=\sum_{a\in A} q(a)\cdot x_{a,p}$ and $\beta_2=y_{p,q}$. This results
in the following linear constraints:
\begin{eqnarray}
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  \sum_{a\in A} q(a)\cdot x_{a,p} - y_{p,q} \geq 0 \nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  K\cdot y_{p,q} - \sum_{a\in A} q(a)\cdot x_{a,p}  \geq 0 
\end{eqnarray}

Our third constraint is that, if an attribute $a$ is assigned to a partition
$p$, and partition $p$ is used by a query $q$, then the corresponding $z$
variable must be set to $1$. That is, we want: $\forall_{\{a,p,q\}\in A\times
[1..k]\times Q}, z_{a,p,q}=\mathbf{1}(x_{a,p} = y_{p,q} = 1)$. We express this
as a linear  constraint, as follows:
\begin{eqnarray}
\forall_{\{a,p,q\}\in A\times [1..k]\times Q},
    && z_{a,p,q} - (x_{a,p} + y_{p,q}) \geq -1\label{eq:no-z}
\end{eqnarray}

In Eq.~\ref{eq:no-z}, when the $x$ and $y$ variables are both $1$, the  $z$
variable is simply forced to be $1$. Otherwise, the $z$ variable can be either
$0$ or $1$, but since the $z$ variables appear in the objective fucntion as
positive terms, the solver will set them to $0$, which is what we want. 

Our fourth constraint is that, if a partition is non-empty, then its
corresponding $u$ variable must be set to $0$. In other words,  we want
$\forall_{p\in[1..k]}, u_p = \mathbf{1}(\sum_{a\in A} x_{a,p}>0)$. This is
expressed as linear constraints, as follows:
\begin{eqnarray}
\forall_{p\in[1..k]},
    && \sum_{a\in A} x_{a,p} - u_p \geq 0 \nonumber\\
\forall_{p\in[1..k]},
    && K\cdot u_p - \sum_{a\in A} x_{a,p} \geq 0 \label{eq:no-u}
\end{eqnarray}

Eq.~\ref{eq:no-u} uses the same construction as the second constraint, where
$\beta_1=\sum_{a\in A} x_{a,p}$ and $\beta_2=u_p$.

Our fifth, and the last, constraint deals with the storage overhead. We want to
 make sure that the storage overhead does not go over $\alpha$. The storage
overhead depends on the number of partitions used. That means that the only 
ILP variables it depends on is the $u$s. In particular, the number of
partitions used is given by $\sum_{p=1}^{k} u_p$. This results in the
following linear constraint:
\begin{equation}
\sum_{p=1}^{k} u_p - 1 \leq \frac{\alpha}
  {1-\frac{c_e(B)\cdot \sum_{a\in A} s(a)}{s(B)}}
\end{equation}

% NOTE: In the simulation we will have query weights that will factor into the objective function
\begin{figure}[!t]
\begin{mdframed}
\begin{eqnarray}
\text{minimize}  
    \sum_{q\in Q} \sum_{p=1}^{k} && (16\cdot c_e(B) + 12\cdot c_n(B))\cdot y_{p,q}\nonumber\\
    &+& \sum_{a\in A} s(a)\cdot c_e(B)\cdot z_{a,p,q} \nonumber\\
\text{subject to}&&\nonumber\\
\forall_{a\in A}, 
    && \sum_{p=1}^{k} x_{a,p} = 1\nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  \sum_{a\in A} q(a)\cdot x_{a,p} - y_{p,q} \geq 0 \nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  K\cdot y_{p,q} - \sum_{a\in A} q(a)\cdot x_{a,p}  \geq 0 \nonumber\\
\forall_{\{a,p,q\}\in A\times [1..k]\times Q},
    && z_{a,p,q} - (x_{a,p} + y_{p,q}) \geq -1\nonumber\\
\forall_{p\in[1..k]},
    && \sum_{a\in A} x_{a,p} - u_p \geq 0 \nonumber\\
\forall_{p\in[1..k]},
    && K\cdot u_p - \sum_{a\in A} x_{a,p} \geq 0 \nonumber\\    
&& \sum_{p=1}^{k} u_p -1 \leq \frac{\alpha}
  {1-\frac{c_e(B)\cdot \sum_{a\in A} s(a)}{s(B)}} \nonumber
\end{eqnarray}
\end{mdframed}
\caption{ILP formulation for the non-overlapping partitioning}
\label{fig:no-ilp}
\end{figure}

The final ILP formulation for the non-overlapping partitioning is given in
Figure~\ref{fig:no-ilp}.

\subsubsection{Heuristic Solution}

\paragraph*{Approach.$\,$}
TODO

\begin{algorithm}[ht]
\scriptsize
\caption{Algorithm for partitioning blocks into sub-blocks with non-overlapping attributes.}
\label{alg:overlappingP}
\KwData{$B$: block, $Q$: set of queries}
$c^*\leftarrow \infty$ \tcp*{Lowest cost over all \# of partitions}
\For(\tcp*[f]{For each possible \# of partitions}){$k=1$ to $|A|$}{
   $R[i]\leftarrow \emptyset, \forall i\in [1..k]$ \tcp*{Initialize partitions}
   \For(\tcp*[f]{For each attribute}){$a \in A$\textnormal{, in decr.\/ order of }$f(a)$}{
      $c\leftarrow \infty$ \tcp*{Lowest cost over all assignments}  
      $j\leftarrow -1$ \tcp*{Best partition assignment}
      \For(\tcp*[f]{For each partition assignment}){$i\in [1..k]$} {
         $R[i]\leftarrow R[i] \cup \{a\}$\tcp*{Assign attribute}
         \If(\tcp*[f]{If query cost is lower}){$L(R, B, Q)<c$}{
            $c\leftarrow L(R, B, Q)$\tcp*{Update the lowest cost}
            $j\leftarrow i$\tcp*{Update the best partition}
         }
         $R[i]\leftarrow R[i] \setminus \{a\}$\tcp*{Un-assign attribute}
      }
      $R[j]\leftarrow R[j] \cup \{a\}$\tcp*{Assign to best partition}
   }
   \tcp{If solution is feasable and has lower cost}
   \If{$H(R, B, Q)\geq\alpha \wedge L(R, B, Q)<c^*$}{
      $c^* \leftarrow L(R, B, Q)$\tcp*{Update the lowest cost}
      $\mathcal{P}(B)\leftarrow R$\tcp*{Update the best partitioning}
   }
}
\Return $\mathcal{P}(B)$ \tcp*{Final set of sub-blocks}
\end{algorithm} 

\clearpage
\newpage
\subsection{Overlapping Attributes}

\paragraph*{Problem.} \emph{Find an overlapping partitioning of attributes that minimizes
  the query I/O and bounds the storage cost by some upper limit.}

\subsubsection{Integer Linear Program Formulation}
% NOTE: In the simulation we will have query weights that will factor into the objective function
\begin{eqnarray}
\text{minimize}  
    \sum_{q\in Q} \sum_{p=1}^{k} && (16\cdot c_e(B) + 12\cdot c_n(B))\cdot y_{p,q}\nonumber\\
    &+& \sum_{a\in A} s(a)\cdot c_e(B)\cdot z_{a,p,q} \nonumber\\
\text{subject to}&&\nonumber\\
\forall_{a\in A}, 
    && \sum_{p=1}^{k} x_{a,p} > 0\nonumber\\
\forall_{a\in A}, 
    && \sum_{p=1}^{k} x_{a,p} \leq k\nonumber\\
\forall_{\{a,q\}\in A\times Q},
    &&  \sum_{p=1}^{k} z_{a,p,q} \geq q(a) \nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  \sum_{a\in A} z_{a,p,q} - y_{p,q} \geq 0 \nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  K\cdot y_{p,q} - \sum_{a\in A} z_{a,p,q}  \geq 0 \nonumber\\
\forall_{\{a,p,q\}\in A\times [1..k]\times Q}, 
    && z_{a,p,q} - (x_{a,p} + y_{p,q}) \geq -1 \nonumber\\
\forall_{p\in[1..k]},
    && \sum_{a\in A} x_{a,p} - u_p \geq 0 \nonumber\\
\forall_{p\in[1..k]},
    && K\cdot u_p - \sum_{a\in A} x_{a,p} \geq 0 \nonumber\\    
&& \sum_{p=1}^{k} u_p -1 \leq \frac{\alpha}
  {1-\frac{c_e(B)\cdot \sum_{a\in A} s(a)}{s(B)}} \nonumber
\end{eqnarray}

\subsubsection{Heuristic Solution}

\paragraph*{Approach.} We start the algorithm with a 
 partitioning based on what queries we have seen.
Every query gets its own sub-block. This is the``ideal'' partitioning,
because the I/O cost would be minimized for every query that we would
have seen. As input to the algorithm, we provide a function $\dist$, which
is used to compute the distance between two blocks.

$$
\dist: block \rightarrow block \rightarrow int
$$

Note that the $\dist$ function can be chosen arbitrarily.  Examples of useful
$\dist$ functions are the frequencies with which the queries are accessed, or the Jaccard index, which measures the set-similarity of
the attributes.

Using this function, the algorithm iteratively combines the two partitions that
are closest together. Algorithm~\ref{alg:closestBF} shows the pseudocode for a brute-force approach
  to finding the closest paris that runs in $O(n^2)$ time. However, there is
  also a divide-and-conquer algorithm~\cite{cormen01} for solving closest pair
  of points problem in $O(n \log n)$.
After each combination of partitions, the algorithm calculate the storage cost
for the partitioning. The algorithm stops when the  storage cost is below some
specified threshold.  The result is the block partitioning.



\begin{algorithm}[ht]
\SetKwFunction{closestPair}{closestPair}
\scriptsize
\caption{Algorithm for partitioning blocks into sub-blocks with overlapping attributes.}
\label{alg:closestPair}
\KwData{$B$: block, $Q$: set of queries}
$\mathcal{P}(B) \leftarrow \emptyset;$  \tcp*{Sub-blocks;}

\For(\tcp*[f]{Every query gets its own sub-block}){$q \in Q$}{ 
 $\mathcal{P}(B) = \mathcal{P}(B) \cup q.A$ 
}

\While(\tcp*[f]{While storage exceeds threshold}){$H(\mathcal{P}, B) \geq
  \text{max}$}{
$\text{x}, \text{y}  \leftarrow  \closestPair{}  $\;
 $ \mathcal{P}(B)  \leftarrow \mathcal{P}(B) - \{x, y\}$ \;
  $\mathcal{P}(B)  \leftarrow \mathcal{P}(B)  \cup \{ x \cup y \}$ \;
}
\Return $ \mathcal{P}(B)$  \tcp*{Final set of sub-blocks}
\end{algorithm} 



 \begin{algorithm}[ht]
\SetKwFunction{length}{length}
\SetKwFunction{dist}{dist}
 \scriptsize
 \caption{Brute-force algorithm for closest points in $O(n^2)$.}
 \label{alg:closestBF}
$minDist  \gets \infty $ \;
\For{$i \gets 1$ \textbf{to} $\length(P)-1$} {
\For{$j \gets i+ 1$ \textbf{to} $\length(P)$} {

  $p \gets P[i]$ \;
  $q \gets P[j]$ \;
  \If{$\dist(p,q) < minDist$} {
    $minDist \gets \dist(p,q)$\;
    $closestPair \gets (p,q)$\;
  }
}
}
\Return $closestPair$
% \KwData{$B$: block, $Q$: set of queries}
% $\mathcal{P}(B) \leftarrow \emptyset;$  \tcp*{Sub-blocks;}
% \For(\tcp*[f]{Every query gets its own sub-block}){$q \in Q$}{ 
%  $\mathcal{P}(B) = \mathcal{P}(B) \cup q.A$ 
% }
% \While(\tcp*[f]{While storage exceeds threshold}){$H(\mathcal{P}, B) \geq
%   \text{max}$}{
% $\text{x}, \text{y}  \leftarrow  \closestPair{}  $\;
%  $ \mathcal{P}(B)  \leftarrow \mathcal{P}(B) - x - y$ \;
%   $\mathcal{P}(B)  \leftarrow \mathcal{P}(B)  + x \cup y$ \;
% \Return $ \mathcal{P}(B)$  \tcp*{Final set of sub-blocks}
 \end{algorithm} 