\section{Partitioning}
This section is still a work-in-progress. We are trying to find the algorithms.

\subsection{Non-Overlapping Attributes}

\paragraph*{Problem.}\emph{Find a true partitioning of attributes that minimizes
  the query I/O and bounds the storage cost by some upper limit.}

%$\mathcal{P}(B) \leftarrow \emptyset$ \tcp*{Initial partitioning}

\begin{algorithm}[ht]
\scriptsize
\caption{Algorithm for partitioning blocks into sub-blocks with non-overlapping attributes.}
\label{alg:overlappingP}
\KwData{$B$: block, $Q$: set of queries}
$c^*\leftarrow \infty$ \tcp*{Lowest cost over all \# of partitions}
\For(\tcp*[f]{For each possible \# of partitions}){$k=1$ to $|A|$}{
   $R[i]\leftarrow \emptyset, \forall i\in [1..k]$ \tcp*{Initialize partitions}
   \For(\tcp*[f]{For each attribute}){$a \in A$\textnormal{, in decr.\/ order of }$f(a)$}{
      $c\leftarrow \infty$ \tcp*{Lowest cost over all assignments}  
      $j\leftarrow -1$ \tcp*{Best partition assignment}
      \For(\tcp*[f]{For each partition assignment}){$i\in [1..k]$} {
         $R[i]\leftarrow R[i] \cup \{a\}$\tcp*{Assign attribute}
         \If(\tcp*[f]{If query cost is lower}){$L(R, B, Q)<c$}{
            $c\leftarrow L(R, B, Q)$\tcp*{Update the lowest cost}
            $j\leftarrow i$\tcp*{Update the best partition}
         }
         $R[i]\leftarrow R[i] \setminus \{a\}$\tcp*{Un-assign attribute}
      }
      $R[j]\leftarrow R[j] \cup \{a\}$\tcp*{Assign to best partition}
   }
   \tcp{If solution is feasable and has lower cost}
   \If{$H(R, B, Q)\geq\alpha \wedge L(R, B, Q)<c^*$}{
      $c^* \leftarrow L(R, B, Q)$\tcp*{Update the lowest cost}
      $\mathcal{P}(B)\leftarrow R$\tcp*{Update the best partitioning}
   }
}
\Return $\mathcal{P}(B)$ \tcp*{Final set of sub-blocks}
\end{algorithm} 

\subsection{Mixed Integer Linear Program Formulation}
$x_{a,p}$: $1$ if attribute $a$ is in partition $p$, $0$ otherwise.\\
$y_{p,q}$: $1$ if partition $p$ is used by query $q$, $0$ otherwise.\\
$z_{a,p,q}$: $1$ if partition $p$ is used by query $q$, and attribute $a$ is in partition $p$, $0$ otherwise.\\
$u_{p}$: $1$ if partition $p$ is assigned at least $1$ attribute, $0$ otherwise.\\

Let $q(a)\equiv \mathbf{1}(a \in q.A)$.

% NOTE: In the simulation we will have query weights that will factor into the objective function
\begin{eqnarray}
\text{minimize}  
    \sum_{q\in Q} \sum_{p=1}^{k} && (16\cdot c_e(B) + 12\cdot c_n(B))\cdot y_{p,q}\nonumber\\
    &+& \sum_{a\in A} s(a)\cdot c_e(B)\cdot z_{a,p,q} \nonumber\\
\text{subject to}&&\nonumber\\
\forall_{a\in A}, 
    && \sum_{p=1}^{k} x_{a,p} = 1\nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  \sum_{a\in A} q(a)\cdot x_{a,p} - y_{p,q} \geq 0 \nonumber\\
\forall_{\{p,q\}\in [1..k]\times Q}, 
    &&  K\cdot y_{p,q} - \sum_{a\in A} q(a)\cdot x_{a,p}  \geq 0 \nonumber\\
\forall_{\{a,p,q\}\in A\times [1..k]\times Q},
    && z_{a,p,q} - (x_{a,p} + y_{p,q}) \geq -1\nonumber\\
\forall_{p\in[1..k]},
    && \sum_{a\in A} x_{a,p} - u_p \geq 0 \nonumber\\
\forall_{p\in[1..k]},
    && K\cdot u_p - \sum_{a\in A} x_{a,p} \geq 0 \nonumber\\    
 && \sum_{p=1}^{k} u_p -1 \leq \frac{\alpha}{
1-\frac{c_e(B)\cdot \sum_{a\in A} s(a)}{s(B)}
 } \nonumber
\end{eqnarray}

Here we use the following LP construction. Assume we have two variables,
$\beta_1$ and $\beta_2$, where $\beta_2\in[0,1]$ and $\beta_1\geq 0$. We want to
implement the following constraint: 
$$
\beta_2 = 
\begin{cases}
0 & \beta_1 = 0 \\
1 & \beta_1 \geq 0 
\end{cases}
$$ 

This could be expressed as a linear constraint as follows,  where $K$ is a
large constant guaranteed to be larger  that $\beta_1$ for practical purposes:
\begin{eqnarray}
\hspace{2cm}&& \beta_1 - \beta_2 \geq 0\nonumber\\
\hspace{2cm}&& K\cdot\beta_2 - \beta_1 \geq 0\nonumber
\end{eqnarray}

In our ILP formulation, we use this construction twice. The first use is shown
in the second and third constrants, where $\beta_1=\sum_{a\in A} q(a)\cdot
x_{a,p}$ and $\beta_2=y_{p,q}$. The second use is shown in the fifth and 
sixth constaints, where $\beta_1=\sum_{a\in A} x_{a,p}$ and $\beta_2=u_p$.

\subsection{Overlapping Attributes}

\paragraph*{Problem.}\emph{Find an overlapping partitioning of attributes that minimizes
  the query I/O and bounds the storage cost by some upper limit.}

\paragraph*{Approach.} We start the algorithm with a 
 partitioning based on what queries we have seen.
Every query gets its own sub-block. This is the``ideal'' partitioning,
because the I/O cost would be minimized for every query that we would
have seen. As input to the algorithm, we provide a function $\dist$, which
is used to compute the distance between two blocks.

$$
\dist: block \rightarrow block \rightarrow int
$$

Note that the $\dist$ function can be chosen arbitrarily.  Examples of useful
$\dist$ functions are the frequencies with which the queries are accessed, or the Jaccard index, which measures the set-similarity of
the attributes.

Using this function, the algorithm iteratively combines the two partitions that
are closest together. Algorithm~\ref{alg:closestBF} shows the pseudocode for a brute-force approach
  to finding the closest paris that runs in $O(n^2)$ time. However, there is
  also a divide-and-conquer algorithm~\cite{cormen01} for solving closest pair
  of points problem in $O(n \log n)$.
After each combination of partitions, the algorithm calculate the storage cost
for the partitioning. The algorithm stops when the  storage cost is below some
specified threshold.  The result is the block partitioning.



\begin{algorithm}[ht]
\SetKwFunction{closestPair}{closestPair}
\scriptsize
\caption{Algorithm for partitioning blocks into sub-blocks with overlapping attributes.}
\label{alg:closestPair}
\KwData{$B$: block, $Q$: set of queries}
$\mathcal{P}(B) \leftarrow \emptyset;$  \tcp*{Sub-blocks;}

\For(\tcp*[f]{Every query gets its own sub-block}){$q \in Q$}{ 
 $\mathcal{P}(B) = \mathcal{P}(B) \cup q.A$ 
}

\While(\tcp*[f]{While storage exceeds threshold}){$H(\mathcal{P}, B) \geq
  \text{max}$}{
$\text{x}, \text{y}  \leftarrow  \closestPair{}  $\;
 $ \mathcal{P}(B)  \leftarrow \mathcal{P}(B) - \{x, y\}$ \;
  $\mathcal{P}(B)  \leftarrow \mathcal{P}(B)  \cup \{ x \cup y \}$ \;
}
\Return $ \mathcal{P}(B)$  \tcp*{Final set of sub-blocks}
\end{algorithm} 



 \begin{algorithm}[ht]
\SetKwFunction{length}{length}
\SetKwFunction{dist}{dist}
 \scriptsize
 \caption{Brute-force algorithm for closest points in $O(n^2)$.}
 \label{alg:closestBF}
$minDist  \gets \infty $ \;
\For{$i \gets 1$ \textbf{to} $\length(P)-1$} {
\For{$j \gets i+ 1$ \textbf{to} $\length(P)$} {

  $p \gets P[i]$ \;
  $q \gets P[j]$ \;
  \If{$\dist(p,q) < minDist$} {
    $minDist \gets \dist(p,q)$\;
    $closestPair \gets (p,q)$\;
  }
}
}
\Return $closestPair$
% \KwData{$B$: block, $Q$: set of queries}
% $\mathcal{P}(B) \leftarrow \emptyset;$  \tcp*{Sub-blocks;}
% \For(\tcp*[f]{Every query gets its own sub-block}){$q \in Q$}{ 
%  $\mathcal{P}(B) = \mathcal{P}(B) \cup q.A$ 
% }
% \While(\tcp*[f]{While storage exceeds threshold}){$H(\mathcal{P}, B) \geq
%   \text{max}$}{
% $\text{x}, \text{y}  \leftarrow  \closestPair{}  $\;
%  $ \mathcal{P}(B)  \leftarrow \mathcal{P}(B) - x - y$ \;
%   $\mathcal{P}(B)  \leftarrow \mathcal{P}(B)  + x \cup y$ \;
% \Return $ \mathcal{P}(B)$  \tcp*{Final set of sub-blocks}
 \end{algorithm} 