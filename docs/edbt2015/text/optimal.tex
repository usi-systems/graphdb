\section{Optimal Railway Design}\label{sec:optimal}  
\noindent
The optimal railway design concerns the partitioning of disk blocks into
sub-blocks such that the query I/O is minimized, while the storage overhead
induced is kept below a desired threshold. This optimization is guided by the
query workload observed by a disk block within a particular time range.

The partitioning of disk blocks into sub-blocks can be \emph{non-overlapping}
or \emph{overlapping}. In the non-overlapping case, the attributes are
partitioned among the sub-blocks with no overlap. In the overlapping case, the
subset of attributes contained within sub-blocks can overlap. In both cases,
the complete graph structure for the block is replicated within the
sub-blocks, which results in a storage overhead.

In both overlapping and non-overlapping partitioning, we trade increased
storage overhead for reduced query I/O cost. In the overlapping case, the
increase in the storage overhead is higher, as some of the attributes are
replicated, in addition to the graph structure. On the other hand, enabling
overlapping attributes is expected to reduce the query I/O (in the extreme
case, there could be one sub-block per query). While the non-overlapping
partitioning scenario is a special case of the  overlapping one, specialized
algorithms can be used to solve the former problem.

In the rest of this section, we first introduce basic notation and then
formulate the overall optimization problem. The modeling of the query I/O and
storage overhead are presented next, which complete the formalization of the
optimal railway design problem.

\subsection{Basic Notation}
\noindent
Let $Q$ be the query workload, where each query $q\in Q$ accesses a set of
attributes $q.A$ and traverses parts of the graph for the time range
$q.T=[q.t_s,q.t_e]$. We denote the set of all attributes as $A$. Given a block
$B$, we denote its time range as $B.T$, which is the union of the time ranges
of its temporal neighborlists. Let $s(a)$ denote the size of an attribute $a$.
We use $c_n(B)$ to denote the number of temporal neighborlists within block
$B$ and $c_e(B)$ to denote the total number of edges in the temporal
neighborlists within the block. We overload the notation for block size and
use $s(B)$ to denote the size of a block $B$. We have: 
\begin{equation}
s(B) = c_e(B) \cdot \Big(16 + \sum_{a\in B.A} s(a)\Big) + c_n(B) \cdot 12  
\end{equation}
Here, $16$ corresponds to the cost of storing the edge id and the timestamp,
and $12$ corresponds to the cost of storing the head vertex ($8$ bytes) plus
the number of entries ($4$ bytes) for a temporal neighborlist. 

Our goal is to create a potentially overlapping partitioning of attributes for
block $B$, resulting in a set of sub-blocks denoted by $\mathcal{P}(B)$. In
other words, we have $\bigcup_{B'\in \mathcal{P}(B)} B'.A = A$. Here,
$\mathcal{P}$ is the partitioning function.

\subsection{Optimization Problem}
\noindent
We aim to find the partitioning function $\mathcal{P}$ that minimizes the query
I/O over $B$, while keeping the storage overhead below a limit, say
$1+\alpha$ times the original. The original corresponds to the case of a single
block that contains all the attributes. Let us denote the query I/O as
$L(\mathcal{P}, B)$ and the storage overhead as $H(\mathcal{P}, B)$,
our goal is to find: 
\begin{equation} 
\mathcal{P} \leftarrow \mbox{argmin}_{\{\mathcal{P}: H(\mathcal{P}(B)) < \alpha\}} L(\mathcal{P},B)
\end{equation}

\subsection{Storage Overhead Formulation}
\noindent
The storage overhead is defined as the additional amount of disk space used to
store the sub-blocks, normalized by the original space needed by a single
block (no partitioning). The storage overhead can be formalized as follows,
for the non-overlapping case:
\begin{equation}
H(\mathcal{P}, B) = (|\mathcal{P}(B)|-1)\cdot\Big(1-\frac{c_e(B)\cdot \sum_{a\in A} s(a)}{s(B)}\Big)
\label{eq:nov}
\end{equation}

Basically, for the non-overlapping case, there is no overhead due to the
attributes, as they are not repeated. However, there is overhead for the block
structure that is repeated for each sub-block. There are $|\mathcal{P}(B)|-1$
such extra sub-blocks, and for each, the contribution to the overhead due to
storing the graph structure is given by $s(B)-c_e(B)\cdot \sum_{a\in A} s(a)$.
Equation~\ref{eq:nov} has one nice feature, that is, it does not depend on the
details of the attribute partitioning, other than the number of partitions. We
make use of this feature, later for the ILP formulation of the problem.

For the general case of a potentially overlapping partitioning, we can
formulate the storage overhead as follows:
\begin{equation}
H(\mathcal{P}, B) = \frac{\sum_{B'\in \mathcal{P}(B)} s(B')}{s(B)} - 1 
\end{equation}

This formulation follows directly from the definition of storage overhead.
While simple, it depends on the details of the partitioning, as $s(B')$ is the
size of a sub-block $B'$, which depends on the list of attributes within the
sub-block.

\subsection{Query I/O Formulation}
\noindent
Let $m$ be a function that maps a query $q$ to the set of sub-blocks that are
accessed to satisfy it for a relevant block $B$ under a given partitioning
$\mathcal{P}$. 

For the case of non-overlapping attributes, the $m$ function lists all the 
sub-blocks whose attributes intersect with those from the query. Formally:
\begin{equation}
m(\mathcal{P}, B, q) = \{B': B'\in \mathcal{P}(B) \wedge q.A \cap B'.A \ne \emptyset\}  
\end{equation}

For the case of overlapping attributes, we use a simple heuristic to define the
set of sub-blocks used for answering the query. Algorithm~\ref{alg:greedyM}
captures it. The basic idea is to start with an empty list of sub-blocks and
greedily add new sub-blocks to it, until all query attributes are covered.  At
each iteration, the sub-block that brings the highest relative marginal gain
is  picked. The relative marginal gain is defined as  the total size of the
attributes from the sub-block that contribute to the query result, relative to
the sub-block size. While computing the marginal gain, attributes that are
already covered by sub-blocks that are selected earlier are not considered.

%
\begin{algorithm}[ht]
\scriptsize
\caption{m-overlapping($\mathcal{P}, B, q$)}
\label{alg:greedyM}
\KwData{$\mathcal{P}$: partitioning function, $B$: block, $q$: query}
$S\leftarrow \emptyset; R\leftarrow \emptyset$ \tcp*{Selected attributes; Resulting sub-blocks}
\While(\tcp*[f]{While unselected attributes remain}){$S \subset q.A$}{
  $B' \leftarrow \mbox{argmax}_{B'\in\mathcal{P}(B)\setminus R} \sum_{a\in B'.A \cap q.A \setminus S} \frac{c_e(B') \cdot s(a)}{s(B')}$
  $S \leftarrow S \cup B'.A$\tcp*{Extend the selected attributes}
  $R\leftarrow R \cup B'$\tcp*{Extend the selected sub-blocks}
}
\Return R \tcp*{Final set of sub-blocks covering the query attributes}
\end{algorithm} 

HERE
The query I/O cost for a block is then given by:
\begin{equation}
L(\mathcal{P}, B) = \sum_{q\in Q} w(q)\cdot\mathbf{1}(q.T \cap B.T \neq \emptyset) \cdot \sum_{B'\in m(\mathcal{P}, B, q)} \!\!s(B')
\end{equation}

Here, $w(q)$ represents the query weight.


