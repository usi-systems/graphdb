\section{Introduction}\label{sec:introduction}

Graph databases, and \emph{interaction graph} databases in particular, are a
critical component for many of today's most popular applications.  Graph
databases store entities as vertices, relationships as edges, and have data
associated with either vertices or edges, called \emph{attributes} or
\emph{properties}.  Interaction graphs differ from general graphs in that they
are \emph{append-only}, and edges are assigned a \emph{temporal value}.  Thus,
interaction graphs encode the relationships over time between entities in
their structure, making them ideal for use in social networking,
telecommunications, or modeling the world-wide web.

To query an interaction graph, most algorithms traverse the graph structure to
access the relevant attributes.  Frequently, there are correlations among the
attributes accessed by different queries. For example, queries $q_1$ and $q_5$
might access attributes $a_1$ and $a_2$, while queries $q_2$, $q_3$ and $q_4$
access attributes $a_3$ and $a_4$. Because interaction graphs are temporal,
the co-access correlations for the attributes can vary for different temporal
regions.  Moreover, the co-access correlations might be unknown at the
insertion time, but be discovered later, when the workload is known.

It is widely recognized that query workload and disk layout have a significant
impact on database performance~\cite{alagiannis14,grund10,stonebraker05}.  For
table-based, relational databases, this fact has led database designers to
develop alternative approaches for storage layout: row-oriented storage is
more efficient when queries access many attributes from a small number of
records, and column-oriented storage is more efficient when queries access a
small number of attributes from many records~\cite{stonebraker05}. 
Unfortunately, although interaction graph databases, like relational
databases, are the target of diverse query workloads, there is no clear
correspondence to a row-oriented or column-oriented storage layout.

Typically, an interaction graph database is organized as blocks of temporal
neighbor lists.  Attributes can be stored in two ways, either separately
(e.g., in a relational table), or locally with the temporal neighbor lists. 
If they are stored separately, then the graph database cannot take advantage
of locality optimizations performed for block organization.  As discussed in
Gedik et al.~\cite{gedik14}, the database must go back and forth between the
disk blocks to access the edge attributes.  On the other hand, if attributes
are stored locally in the disk blocks containing the graph structure, then
there can be significant overhead due to disk I/O if only a few attributes are
needed to answer a query.

This paper presents an algorithm for adaptively optimizing disk block storage
for interaction graphs. The key idea behind the approach is a novel storage
scheme, called a \emph{rail layout}.  Initially, attributes are stored with
their neighbor lists in large blocks. Over time, the blocks are split into
smaller-blocks that contain the neighbor lists, but only subsets of the
attributes, depending on the query workload. Intuitively, this is almost like
having two or more graph databases for certain time regions, each containing a
different subset of the attributes, but with a link between them in case a
query needs to access both.

% This points to the need for
% adaptively optimizing the layout (somewhat similar to H2O \cite{alagiannis14}
% and HYRISE~\cite{grund10}).%



