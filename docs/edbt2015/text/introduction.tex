\section{Introduction}\label{sec:introduction}

We are living in an ever more connected world, where the data generated by
people, software systems, and the physical world is more accessible than
before and is much larger in volume, variety, and velocity. In many
application domains, such as telecommunications and social media, live data
recording the interactions between people, systems, and the environment is
available for analysis. This data often takes the form of a temporally
evolving graph, where entities are the vertices and the interactions between
them are the edges. We call such graphs \emph{interaction graphs}. 

Data analytics performed on interaction graphs can bring new business insights
and improve decision making. For instance, the graph structure may represent
the interactions in a social network, where finding communities in the graph
can facilitate targeted advertising. In the telecommunications (telco) domain,
call details records (CDRs) can be used to capture the call interactions
between people, and locating closely connected groups of people can be used
for generating promotions. 

Interaction graphs are temporal in nature, and more importantly, they are
append-only. This is in contrast to relationship graphs, which are updated via
insertion and deletion operations. An example of a relationship graph is a
social network capturing the follower-followee relationship among users.
Examples of interactions graphs include CDR graphs capturing calls between
telco customers or mention graphs capturing interactions between users of a
micro-blogging service. The append-only nature of the interaction graphs make
storing them on disk a necessity. Furthermore, the analysis of this historical
interaction data form an important aspect of the analytical landscape.

The ability to efficiently support historical analysis over interaction graphs
require effective solutions for the problem of \emph{data layout} on the disk.

% Importance of the data layout on disk and locality 
% Earlier work on blocks formed of temporal neighborlists  

% Attributes associated with interactions
% I/O inefficiency due to attributes that are not accessed
% Similar to the problem of row vs column stores

% Challenges: finding the right partitioning
% what if the access pattern changes over time
% query access patterns are different over different time ranges 

% Solution: railway layout 
% adaptive layout optimization
% algorithms for optimal partitioning
% heuristics & evaluation

Graph databases, and \emph{interaction graph} databases in particular, are a
critical component for many of today's most popular applications.  Graph
databases store entities as vertices, relationships as edges, and have data
associated with either vertices or edges, called \emph{attributes} or
\emph{properties}.  Interaction graphs differ from general graphs in that they
are \emph{append-only}, and edges are assigned a \emph{temporal value}.  Thus,
interaction graphs encode the relationships over time between entities in
their structure, making them ideal for use in social networking,
telecommunications, or modeling the world-wide web.

To query an interaction graph, most algorithms traverse the graph structure to
access the relevant attributes.  Frequently, there are correlations among the
attributes accessed by different queries. For example, queries $q_1$ and $q_5$
might access attributes $a_1$ and $a_2$, while queries $q_2$, $q_3$ and $q_4$
access attributes $a_3$ and $a_4$. Because interaction graphs are temporal,
the co-access correlations for the attributes can vary for different temporal
regions.  Moreover, the co-access correlations might be unknown at the
insertion time, but be discovered later, when the workload is known.

It is widely recognized that query workload and disk layout have a significant
impact on database performance~\cite{alagiannis14,grund10,stonebraker05}.  For
table-based, relational databases, this fact has led database designers to
develop alternative approaches for storage layout: row-oriented storage is
more efficient when queries access many attributes from a small number of
records, and column-oriented storage is more efficient when queries access a
small number of attributes from many records~\cite{stonebraker05}. 
Unfortunately, although interaction graph databases, like relational
databases, are the target of diverse query workloads, there is no clear
correspondence to a row-oriented or column-oriented storage layout.

Typically, an interaction graph database is organized as blocks of temporal
neighbor lists.  Attributes can be stored in two ways, either separately
(e.g., in a relational table), or locally with the temporal neighbor lists. 
If they are stored separately, then the graph database cannot take advantage
of locality optimizations performed for block organization.  As discussed in
Gedik et al.~\cite{gedik14}, the database must go back and forth between the
disk blocks to access the edge attributes.  On the other hand, if attributes
are stored locally in the disk blocks containing the graph structure, then
there can be significant overhead due to disk I/O if only a few attributes are
needed to answer a query.

This paper presents an algorithm for adaptively optimizing disk block storage
for interaction graphs. The key idea behind the approach is a novel storage
scheme, called a \emph{rail layout}.  Initially, attributes are stored with
their neighbor lists in large blocks. Over time, the blocks are split into
smaller-blocks that contain the neighbor lists, but only subsets of the
attributes, depending on the query workload. Intuitively, this is almost like
having two or more graph databases for certain time regions, each containing a
different subset of the attributes, but with a link between them in case a
query needs to access both.

% This points to the need for
% adaptively optimizing the layout (somewhat similar to H2O \cite{alagiannis14}
% and HYRISE~\cite{grund10}).%



