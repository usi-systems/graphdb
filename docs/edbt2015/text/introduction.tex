\section{Introduction}\label{sec:introduction}

We are living in an ever more connected world, where the data generated by
people, software systems, and the physical world is more accessible than
before and is much larger in volume, variety, and velocity. In many
application domains, such as telecommunications and social media, live data
recording the interactions between people, systems, and the environment is
available for analysis. This data often takes the form of a temporally
evolving graph, where entities are the vertices and the interactions between
them are the edges. We call such graphs \emph{interaction graphs}. 

Data analytics performed on interaction graphs can bring new business insights
and improve decision making. For instance, the graph structure may represent
the interactions in a social network, where finding communities in the graph
can facilitate targeted advertising. In the telecommunications (telco) domain,
call details records (CDRs) can be used to capture the call interactions
between people, and locating closely connected groups of people can be used
for generating promotions. 

Interaction graphs are temporal in nature, and more importantly, they are
append-only. This is in contrast to relationship graphs, which are updated via
insertion and deletion operations. An example of a relationship graph is a
social network capturing the follower-followee relationship among users.
Examples of interactions graphs include CDR graphs capturing calls between
telco customers or mention graphs capturing interactions between users of a
micro-blogging service. The append-only nature of the interaction graphs make
storing them on disk a necessity. Furthermore, the analysis of this historical
interaction data form an important aspect of the analytical landscape.

The ability to efficiently support historical analysis over interaction graphs
require effective solutions for the problem of \emph{data layout} on disk.
Most graph algorithms are characterized by locality of
access~\cite{localityLayout}, which has been taken advantage of co-locating
edges in close proximity within the same disk blocks~\cite{gstoreThesis}. This
ensures that once a disk block is loaded from disk into the main memory
buffers, several edges can be used. The locality of reference is a result of
the traversal-based nature of most of the graph algorithms. 

In interaction graphs, the locality of access is even more pronounced. First, 
the analysis to be performed on the interactions can be restricted to a
temporal view of the graph, such as finding the influential users over a given
week of interactions. This means that edges that are temporally close are to
be accessed together. Second, traversals are again key to many algorithms,
such as connected components, clustering coefficient, PageRank, etc. This
means that edges that are close by in terms of the path between their incident
vertices as well as their timestamps are to be located together with the same
blocks. 

In our earlier work~\cite{gedik14}, we introduced an interaction graph database
that works on this principle of access locality. It proposed a disk
organization that consists of as set of blocks, each containing a list of
\emph{temporal neighbor lists}. A temporal neighborlist contains a head vertex
and a set of incident edges within a given time range. The layout optimizer
aims at bringing together temporal neighborlists that are (i) close in terms
of their temporal ranges, (ii) have many edges between them, and (iii) have
few edges going into temporal neighborlists outside the block.

Many real world graph databases contain attributes. In the case of interaction
graphs, the attributes can be considered as properties associated with the
edges. Attributes can be stored in two ways, either separately (e.g., in a
relational table), or locally with the temporal neighbor lists.  If they are
stored separately, then the graph database cannot take advantage of locality
optimizations performed for block organization. The database must go back and
forth between the disk blocks to access the edge attributes.  On the other
hand, if attributes are stored locally in the disk blocks containing the graph
structure, then there can be significant overhead due to disk I/O if only a
few attributes are needed to answer a query. 

To query an interaction graph, most algorithms traverse the graph structure to
access the relevant attributes.  Frequently, there are correlations among the
attributes accessed by different queries. For example, queries $q_1$ and $q_5$
might access attributes $a_1$ and $a_2$, while queries $q_2$, $q_3$ and $q_4$
access attributes $a_3$ and $a_4$. Because interaction graphs are temporal,
the co-access correlations for the attributes can vary for different temporal
regions.  Moreover, the co-access correlations might be unknown at the
insertion time, but be discovered later, when the workload is known.

It is widely recognized that query workload and disk layout have a significant
impact on database performance~\cite{alagiannis14,grund10,stonebraker05}.  For
table-based, relational databases, this fact has led database designers to
develop alternative approaches for storage layout: row-oriented
storage~\cite{rowOrg} is more efficient when queries access many attributes
from a small number of records, and column-oriented storage~\cite{colOrg} is
more efficient when queries access a small number of attributes from many
records~\cite{stonebraker05}.  Unfortunately, although interaction graph
databases, like relational databases, are the target of diverse query
workloads, there is no clear correspondence to a row-oriented or
column-oriented storage layout.

This paper presents an adaptive disk layout called the \emph{railway layout}
and associated algorithms for optimizing disk block storage for interaction
graphs. The key idea is to divide blocks into one or more sub-blocks, where
each sub-block contains a subset of the attributes (potentially overlapping),
but the entire graph structure is replicated within each sub-block. This way,
a query can be answered completely by only reading the sub-blocks that contain
the attributes of interest, reducing the overall I/O. 

There a number of challenges in achieving an effective adaptive layout. First,
we need to find the partitioning of attributes that optimizes the query I/O.
To address this, we model the problems of overlapping and non-overlapping
attribute partitioning as mixed-integer linear programs (ILPs), and provide
optimal solutions that minimize the I/O cost. Second, the query workload, and
thus the attribute access pattern can change over time. For this purpose, our
railway layout supports customization of the attribute partitioning of
sub-blocks on a per-block basis. Third, such flexibility necessitates online
configuration of attribute partitioning as the query workload evolves, which
in turn requires fast algorithms for performing the attribute partitioning.
For this purpose, we develop greedy heuristic algorithms for both overlapping
and non-overlapping partitioning scenarios. These algorithms can scale to
larger number of attributes, yet provide close to optimal query I/O
performance. Finally, the railroad layout tradeoffs storage space to gain
improved query I/O performance. The storage overhead is more pronounced for
the case of overlapping partitioning. To address this, we limit the amount of
storage  overhead that can be tolerated with an upper limit, and integrate
this limit to both our ILP formulations, as well as our greedy heuristics.

In summary, this paper makes the following contributions:
\begin{itemize}
\item We introduce the railroad layout for adaptive organization of interaction
graphs on disk. 
\item We introduce optimal ILP formulations for partitioning disk blocks into 
sub-blocks with overlapping and non-overlapping attributes, given a query
workload. Our formulation also support upper bounding the amount of storage
overhead introduced as a result of the railroad layout.
\item To support online adaptation, we develop greedy heuristics that can scale
better compared to the ILP alternatives, yet achieve close to optimal query
I/O.
\item We provide an extensive experimental study comparing our approach to a
few baseline alternatives.
\end{itemize}

The rest of the paper is organized as follows. Section...

% This points to the need for
% adaptively optimizing the layout (somewhat similar to H2O \cite{alagiannis14}
% and HYRISE~\cite{grund10}).%



