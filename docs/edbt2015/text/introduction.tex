\section{Introduction}\label{sec:introduction}

We are living in an ever more connected world, where the data generated by
people, software systems, and the physical world is more accessible than
before and is much larger in volume, variety, and velocity. In many
application domains, such as telecommunications and social media, live data
recording the interactions between people, systems, and the environment is
available for analysis. This data often takes the form of a temporally
evolving graph, where entities are the vertices and the interactions between
them are the edges. We call such graphs \emph{interaction graphs}. 

Data analytics performed on interaction graphs can bring new business insights
and improve decision making. For instance, the graph structure may represent
the interactions in a social network, where finding communities in the graph
can facilitate targeted advertising. In the telecommunications (telco) domain,
call details records (CDRs) can be used to capture the call interactions
between people, and locating closely connected groups of people can be used
for generating promotions. 

Interaction graphs are temporal in nature, and more importantly, they are
append-only. This is in contrast to relationship graphs, which are updated via
insertion and deletion operations. An example of a relationship graph is a
social network capturing the follower-followee relationship among users.
Examples of interactions graphs include CDR graphs capturing calls between
telco customers or mention graphs capturing interactions between users of a
micro-blogging service. The append-only nature of the interaction graphs make
storing them on disk a necessity. Furthermore, the analysis of this historical
interaction data form an important aspect of the analytical landscape.

The ability to efficiently support historical analysis over interaction graphs
require effective solutions for the problem of \emph{data layout} on disk.
Most graph algorithms are characterized by locality of
access~\cite{localityLayout}, which has been taken advantage of co-locating
edges in close proximity within the same disk blocks~\cite{gstoreThesis}. This
ensures that once a disk block is loaded from disk into the main memory
buffers, several edges can be used. The locality of reference is a result of
the traversal-based nature of most of the graph algorithms. 

In interaction graphs, the locality of access is even more pronounced. First, 
the analysis to be performed on the interactions can be restricted to a
temporal view of the graph, such as finding the influential users over a given
week of interactions. This means that edges that are temporally close are to
be accessed together. Second, traversals are again key to many algorithms,
such as connected components, clustering coefficient, PageRank, etc. This
means that edges that are close by in terms of the path between their incident
vertices as well as their timestamps are to be located together with the same
blocks. 

In our earlier work, we introduced an interaction graph database~\cite{gedik14}
that works on this principle of access locality. It proposed a disk
organization that consists of as set of blocks, each containing a list of
\emph{temporal neighbor lists}. A temporal neighborlist contains a head vertex
and a set of incident edges within a given time range. The layout optimizer
aims at bringing together temporal neighborlists that are (i) close in terms
of their temporal ranges, (ii) have many edges between them, and (iii) have
few edges going into temporal neighborlists outside the block.

% Attributes associated with interactions
% I/O inefficiency due to attributes that are not accessed
% Similar to the problem of row vs column stores

Attributes can be stored in two ways, either separately
(e.g., in a relational table), or locally with the temporal neighbor lists. 
If they are stored separately, then the graph database cannot take advantage
of locality optimizations performed for block organization.  As discussed in
Gedik et al.~\cite{gedik14}, the database must go back and forth between the
disk blocks to access the edge attributes.  On the other hand, if attributes
are stored locally in the disk blocks containing the graph structure, then
there can be significant overhead due to disk I/O if only a few attributes are
needed to answer a query.


% Challenges: finding the right partitioning
% what if the access pattern changes over time
% query access patterns are different over different time ranges 

% Solution: railway layout 
% adaptive layout optimization
% algorithms for optimal partitioning
% heuristics & evaluation

Graph databases, and \emph{interaction graph} databases in particular, are a
critical component for many of today's most popular applications.  Graph
databases store entities as vertices, relationships as edges, and have data
associated with either vertices or edges, called \emph{attributes} or
\emph{properties}.  Interaction graphs differ from general graphs in that they
are \emph{append-only}, and edges are assigned a \emph{temporal value}.  Thus,
interaction graphs encode the relationships over time between entities in
their structure, making them ideal for use in social networking,
telecommunications, or modeling the world-wide web.

To query an interaction graph, most algorithms traverse the graph structure to
access the relevant attributes.  Frequently, there are correlations among the
attributes accessed by different queries. For example, queries $q_1$ and $q_5$
might access attributes $a_1$ and $a_2$, while queries $q_2$, $q_3$ and $q_4$
access attributes $a_3$ and $a_4$. Because interaction graphs are temporal,
the co-access correlations for the attributes can vary for different temporal
regions.  Moreover, the co-access correlations might be unknown at the
insertion time, but be discovered later, when the workload is known.

It is widely recognized that query workload and disk layout have a significant
impact on database performance~\cite{alagiannis14,grund10,stonebraker05}.  For
table-based, relational databases, this fact has led database designers to
develop alternative approaches for storage layout: row-oriented storage is
more efficient when queries access many attributes from a small number of
records, and column-oriented storage is more efficient when queries access a
small number of attributes from many records~\cite{stonebraker05}. 
Unfortunately, although interaction graph databases, like relational
databases, are the target of diverse query workloads, there is no clear
correspondence to a row-oriented or column-oriented storage layout.


This paper presents an algorithm for adaptively optimizing disk block storage
for interaction graphs. The key idea behind the approach is a novel storage
scheme, called a \emph{rail layout}.  Initially, attributes are stored with
their neighbor lists in large blocks. Over time, the blocks are split into
smaller-blocks that contain the neighbor lists, but only subsets of the
attributes, depending on the query workload. Intuitively, this is almost like
having two or more graph databases for certain time regions, each containing a
different subset of the attributes, but with a link between them in case a
query needs to access both.

% This points to the need for
% adaptively optimizing the layout (somewhat similar to H2O \cite{alagiannis14}
% and HYRISE~\cite{grund10}).%



